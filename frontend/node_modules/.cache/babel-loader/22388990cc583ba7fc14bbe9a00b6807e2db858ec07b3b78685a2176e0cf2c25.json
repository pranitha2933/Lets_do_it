{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RequestSender = void 0;\nconst Error_js_1 = require(\"./Error.js\");\nconst HttpClient_js_1 = require(\"./net/HttpClient.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst MAX_RETRY_AFTER_WAIT = 60;\nclass RequestSender {\n  constructor(stripe, maxBufferedRequestMetric) {\n    this._stripe = stripe;\n    this._maxBufferedRequestMetric = maxBufferedRequestMetric;\n  }\n  _addHeadersDirectlyToObject(obj, headers) {\n    // For convenience, make some headers easily accessible on\n    // lastResponse.\n    // NOTE: Stripe responds with lowercase header names/keys.\n    obj.requestId = headers['request-id'];\n    obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];\n    obj.apiVersion = obj.apiVersion || headers['stripe-version'];\n    obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];\n  }\n  _makeResponseEvent(requestEvent, statusCode, headers) {\n    const requestEndTime = Date.now();\n    const requestDurationMs = requestEndTime - requestEvent.request_start_time;\n    return (0, utils_js_1.removeNullish)({\n      api_version: headers['stripe-version'],\n      account: headers['stripe-account'],\n      idempotency_key: headers['idempotency-key'],\n      method: requestEvent.method,\n      path: requestEvent.path,\n      status: statusCode,\n      request_id: this._getRequestId(headers),\n      elapsed: requestDurationMs,\n      request_start_time: requestEvent.request_start_time,\n      request_end_time: requestEndTime\n    });\n  }\n  _getRequestId(headers) {\n    return headers['request-id'];\n  }\n  /**\n   * Used by methods with spec.streaming === true. For these methods, we do not\n   * buffer successful responses into memory or do parse them into stripe\n   * objects, we delegate that all of that to the user and pass back the raw\n   * http.Response object to the callback.\n   *\n   * (Unsuccessful responses shouldn't make it here, they should\n   * still be buffered/parsed and handled by _jsonResponseHandler -- see\n   * makeRequest)\n   */\n  _streamingResponseHandler(requestEvent, usage, callback) {\n    return res => {\n      const headers = res.getHeaders();\n      const streamCompleteCallback = () => {\n        const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);\n        this._stripe._emitter.emit('response', responseEvent);\n        this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed, usage);\n      };\n      const stream = res.toStream(streamCompleteCallback);\n      // This is here for backwards compatibility, as the stream is a raw\n      // HTTP response in Node and the legacy behavior was to mutate this\n      // response.\n      this._addHeadersDirectlyToObject(stream, headers);\n      return callback(null, stream);\n    };\n  }\n  /**\n   * Default handler for Stripe responses. Buffers the response into memory,\n   * parses the JSON and returns it (i.e. passes it to the callback) if there\n   * is no \"error\" field. Otherwise constructs/passes an appropriate Error.\n   */\n  _jsonResponseHandler(requestEvent, apiMode, usage, callback) {\n    return res => {\n      const headers = res.getHeaders();\n      const requestId = this._getRequestId(headers);\n      const statusCode = res.getStatusCode();\n      const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);\n      this._stripe._emitter.emit('response', responseEvent);\n      res.toJSON().then(jsonResponse => {\n        if (jsonResponse.error) {\n          let err;\n          // Convert OAuth error responses into a standard format\n          // so that the rest of the error logic can be shared\n          if (typeof jsonResponse.error === 'string') {\n            jsonResponse.error = {\n              type: jsonResponse.error,\n              message: jsonResponse.error_description\n            };\n          }\n          jsonResponse.error.headers = headers;\n          jsonResponse.error.statusCode = statusCode;\n          jsonResponse.error.requestId = requestId;\n          if (statusCode === 401) {\n            err = new Error_js_1.StripeAuthenticationError(jsonResponse.error);\n          } else if (statusCode === 403) {\n            err = new Error_js_1.StripePermissionError(jsonResponse.error);\n          } else if (statusCode === 429) {\n            err = new Error_js_1.StripeRateLimitError(jsonResponse.error);\n          } else if (apiMode === 'v2') {\n            err = (0, Error_js_1.generateV2Error)(jsonResponse.error);\n          } else {\n            err = (0, Error_js_1.generateV1Error)(jsonResponse.error);\n          }\n          throw err;\n        }\n        return jsonResponse;\n      }, e => {\n        throw new Error_js_1.StripeAPIError({\n          message: 'Invalid JSON received from the Stripe API',\n          exception: e,\n          requestId: headers['request-id']\n        });\n      }).then(jsonResponse => {\n        this._recordRequestMetrics(requestId, responseEvent.elapsed, usage);\n        // Expose raw response object.\n        const rawResponse = res.getRawResponse();\n        this._addHeadersDirectlyToObject(rawResponse, headers);\n        Object.defineProperty(jsonResponse, 'lastResponse', {\n          enumerable: false,\n          writable: false,\n          value: rawResponse\n        });\n        callback(null, jsonResponse);\n      }, e => callback(e, null));\n    };\n  }\n  static _generateConnectionErrorMessage(requestRetries) {\n    return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ''}`;\n  }\n  // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency\n  static _shouldRetry(res, numRetries, maxRetries, error) {\n    if (error && numRetries === 0 && HttpClient_js_1.HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {\n      return true;\n    }\n    // Do not retry if we are out of retries.\n    if (numRetries >= maxRetries) {\n      return false;\n    }\n    // Retry on connection error.\n    if (!res) {\n      return true;\n    }\n    // The API may ask us not to retry (e.g., if doing so would be a no-op)\n    // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.\n    if (res.getHeaders()['stripe-should-retry'] === 'false') {\n      return false;\n    }\n    if (res.getHeaders()['stripe-should-retry'] === 'true') {\n      return true;\n    }\n    // Retry on conflict errors.\n    if (res.getStatusCode() === 409) {\n      return true;\n    }\n    // Retry on 500, 503, and other internal errors.\n    //\n    // Note that we expect the stripe-should-retry header to be false\n    // in most cases when a 500 is returned, since our idempotency framework\n    // would typically replay it anyway.\n    if (res.getStatusCode() >= 500) {\n      return true;\n    }\n    return false;\n  }\n  _getSleepTimeInMS(numRetries, retryAfter = null) {\n    const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();\n    const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();\n    // Apply exponential backoff with initialNetworkRetryDelay on the\n    // number of numRetries so far as inputs. Do not allow the number to exceed\n    // maxNetworkRetryDelay.\n    let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(2, numRetries - 1), maxNetworkRetryDelay);\n    // Apply some jitter by randomizing the value in the range of\n    // (sleepSeconds / 2) to (sleepSeconds).\n    sleepSeconds *= 0.5 * (1 + Math.random());\n    // But never sleep less than the base sleep seconds.\n    sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);\n    // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n    if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {\n      sleepSeconds = Math.max(sleepSeconds, retryAfter);\n    }\n    return sleepSeconds * 1000;\n  }\n  // Max retries can be set on a per request basis. Favor those over the global setting\n  _getMaxNetworkRetries(settings = {}) {\n    return settings.maxNetworkRetries !== undefined && Number.isInteger(settings.maxNetworkRetries) ? settings.maxNetworkRetries : this._stripe.getMaxNetworkRetries();\n  }\n  _defaultIdempotencyKey(method, settings, apiMode) {\n    // If this is a POST and we allow multiple retries, ensure an idempotency key.\n    const maxRetries = this._getMaxNetworkRetries(settings);\n    const genKey = () => `stripe-node-retry-${this._stripe._platformFunctions.uuid4()}`;\n    // more verbose than it needs to be, but gives clear separation between V1 and V2 behavior\n    if (apiMode === 'v2') {\n      if (method === 'POST' || method === 'DELETE') {\n        return genKey();\n      }\n    } else if (apiMode === 'v1') {\n      if (method === 'POST' && maxRetries > 0) {\n        return genKey();\n      }\n    }\n    return null;\n  }\n  _makeHeaders({\n    contentType,\n    contentLength,\n    apiVersion,\n    clientUserAgent,\n    method,\n    userSuppliedHeaders,\n    userSuppliedSettings,\n    stripeAccount,\n    stripeContext,\n    apiMode\n  }) {\n    const defaultHeaders = {\n      Accept: 'application/json',\n      'Content-Type': contentType,\n      'User-Agent': this._getUserAgentString(apiMode),\n      'X-Stripe-Client-User-Agent': clientUserAgent,\n      'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),\n      'Stripe-Version': apiVersion,\n      'Stripe-Account': stripeAccount,\n      'Stripe-Context': stripeContext,\n      'Idempotency-Key': this._defaultIdempotencyKey(method, userSuppliedSettings, apiMode)\n    };\n    // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:\n    //   A user agent SHOULD send a Content-Length in a request message when\n    //   no Transfer-Encoding is sent and the request method defines a meaning\n    //   for an enclosed payload body.  For example, a Content-Length header\n    //   field is normally sent in a POST request even when the value is 0\n    //   (indicating an empty payload body).  A user agent SHOULD NOT send a\n    //   Content-Length header field when the request message does not contain\n    //   a payload body and the method semantics do not anticipate such a\n    //   body.\n    //\n    // These method types are expected to have bodies and so we should always\n    // include a Content-Length.\n    const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n    // If a content length was specified, we always include it regardless of\n    // whether the method semantics anticipate such a body. This keeps us\n    // consistent with historical behavior. We do however want to warn on this\n    // and fix these cases as they are semantically incorrect.\n    if (methodHasPayload || contentLength) {\n      if (!methodHasPayload) {\n        (0, utils_js_1.emitWarning)(`${method} method had non-zero contentLength but no payload is expected for this verb`);\n      }\n      defaultHeaders['Content-Length'] = contentLength;\n    }\n    return Object.assign((0, utils_js_1.removeNullish)(defaultHeaders),\n    // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.\n    (0, utils_js_1.normalizeHeaders)(userSuppliedHeaders));\n  }\n  _getUserAgentString(apiMode) {\n    const packageVersion = this._stripe.getConstant('PACKAGE_VERSION');\n    const appInfo = this._stripe._appInfo ? this._stripe.getAppInfoAsString() : '';\n    return `Stripe/${apiMode} NodeBindings/${packageVersion} ${appInfo}`.trim();\n  }\n  _getTelemetryHeader() {\n    if (this._stripe.getTelemetryEnabled() && this._stripe._prevRequestMetrics.length > 0) {\n      const metrics = this._stripe._prevRequestMetrics.shift();\n      return JSON.stringify({\n        last_request_metrics: metrics\n      });\n    }\n  }\n  _recordRequestMetrics(requestId, requestDurationMs, usage) {\n    if (this._stripe.getTelemetryEnabled() && requestId) {\n      if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {\n        (0, utils_js_1.emitWarning)('Request metrics buffer is full, dropping telemetry message.');\n      } else {\n        const m = {\n          request_id: requestId,\n          request_duration_ms: requestDurationMs\n        };\n        if (usage && usage.length > 0) {\n          m.usage = usage;\n        }\n        this._stripe._prevRequestMetrics.push(m);\n      }\n    }\n  }\n  _rawRequest(method, path, params, options) {\n    const requestPromise = new Promise((resolve, reject) => {\n      let opts;\n      try {\n        const requestMethod = method.toUpperCase();\n        if (requestMethod !== 'POST' && params && Object.keys(params).length !== 0) {\n          throw new Error('rawRequest only supports params on POST requests. Please pass null and add your parameters to path.');\n        }\n        const args = [].slice.call([params, options]);\n        // Pull request data and options (headers, auth) from args.\n        const dataFromArgs = (0, utils_js_1.getDataFromArgs)(args);\n        const data = Object.assign({}, dataFromArgs);\n        const calculatedOptions = (0, utils_js_1.getOptionsFromArgs)(args);\n        const headers = calculatedOptions.headers;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const authenticator = calculatedOptions.authenticator;\n        opts = {\n          requestMethod,\n          requestPath: path,\n          bodyData: data,\n          queryData: {},\n          authenticator,\n          headers,\n          host: null,\n          streaming: false,\n          settings: {},\n          usage: ['raw_request']\n        };\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      function requestCallback(err, response) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(response);\n        }\n      }\n      const {\n        headers,\n        settings\n      } = opts;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const authenticator = opts.authenticator;\n      this._request(opts.requestMethod, opts.host, path, opts.bodyData, authenticator, {\n        headers,\n        settings,\n        streaming: opts.streaming\n      }, opts.usage, requestCallback);\n    });\n    return requestPromise;\n  }\n  _request(method, host, path, data, authenticator, options, usage = [], callback, requestDataProcessor = null) {\n    var _a;\n    let requestData;\n    authenticator = (_a = authenticator !== null && authenticator !== void 0 ? authenticator : this._stripe._authenticator) !== null && _a !== void 0 ? _a : null;\n    const apiMode = (0, utils_js_1.getAPIMode)(path);\n    const retryRequest = (requestFn, apiVersion, headers, requestRetries, retryAfter) => {\n      return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);\n    };\n    const makeRequest = (apiVersion, headers, numRetries) => {\n      // timeout can be set on a per-request basis. Favor that over the global setting\n      const timeout = options.settings && options.settings.timeout && Number.isInteger(options.settings.timeout) && options.settings.timeout >= 0 ? options.settings.timeout : this._stripe.getApiField('timeout');\n      const request = {\n        host: host || this._stripe.getApiField('host'),\n        port: this._stripe.getApiField('port'),\n        path: path,\n        method: method,\n        headers: Object.assign({}, headers),\n        body: requestData,\n        protocol: this._stripe.getApiField('protocol')\n      };\n      authenticator(request).then(() => {\n        const req = this._stripe.getApiField('httpClient').makeRequest(request.host, request.port, request.path, request.method, request.headers, request.body, request.protocol, timeout);\n        const requestStartTime = Date.now();\n        // @ts-ignore\n        const requestEvent = (0, utils_js_1.removeNullish)({\n          api_version: apiVersion,\n          account: headers['Stripe-Account'],\n          idempotency_key: headers['Idempotency-Key'],\n          method,\n          path,\n          request_start_time: requestStartTime\n        });\n        const requestRetries = numRetries || 0;\n        const maxRetries = this._getMaxNetworkRetries(options.settings || {});\n        this._stripe._emitter.emit('request', requestEvent);\n        req.then(res => {\n          if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {\n            return retryRequest(makeRequest, apiVersion, headers, requestRetries,\n            // @ts-ignore\n            res.getHeaders()['retry-after']);\n          } else if (options.streaming && res.getStatusCode() < 400) {\n            return this._streamingResponseHandler(requestEvent, usage, callback)(res);\n          } else {\n            return this._jsonResponseHandler(requestEvent, apiMode, usage, callback)(res);\n          }\n        }).catch(error => {\n          if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {\n            return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);\n          } else {\n            const isTimeoutError = error.code && error.code === HttpClient_js_1.HttpClient.TIMEOUT_ERROR_CODE;\n            return callback(new Error_js_1.StripeConnectionError({\n              message: isTimeoutError ? `Request aborted due to timeout being reached (${timeout}ms)` : RequestSender._generateConnectionErrorMessage(requestRetries),\n              // @ts-ignore\n              detail: error\n            }));\n          }\n        });\n      }).catch(e => {\n        throw new Error_js_1.StripeError({\n          message: 'Unable to authenticate the request',\n          exception: e\n        });\n      });\n    };\n    const prepareAndMakeRequest = (error, data) => {\n      if (error) {\n        return callback(error);\n      }\n      requestData = data;\n      this._stripe.getClientUserAgent(clientUserAgent => {\n        const apiVersion = this._stripe.getApiField('version');\n        const headers = this._makeHeaders({\n          contentType: apiMode == 'v2' ? 'application/json' : 'application/x-www-form-urlencoded',\n          contentLength: requestData.length,\n          apiVersion: apiVersion,\n          clientUserAgent,\n          method,\n          userSuppliedHeaders: options.headers,\n          userSuppliedSettings: options.settings,\n          stripeAccount: apiMode == 'v2' ? null : this._stripe.getApiField('stripeAccount'),\n          stripeContext: apiMode == 'v2' ? this._stripe.getApiField('stripeContext') : null,\n          apiMode: apiMode\n        });\n        makeRequest(apiVersion, headers, 0);\n      });\n    };\n    if (requestDataProcessor) {\n      requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);\n    } else {\n      let stringifiedData;\n      if (apiMode == 'v2') {\n        stringifiedData = data ? (0, utils_js_1.jsonStringifyRequestData)(data) : '';\n      } else {\n        stringifiedData = (0, utils_js_1.queryStringifyRequestData)(data || {}, apiMode);\n      }\n      prepareAndMakeRequest(null, stringifiedData);\n    }\n  }\n}\nexports.RequestSender = RequestSender;","map":{"version":3,"names":["Object","defineProperty","exports","value","RequestSender","Error_js_1","require","HttpClient_js_1","utils_js_1","MAX_RETRY_AFTER_WAIT","constructor","stripe","maxBufferedRequestMetric","_stripe","_maxBufferedRequestMetric","_addHeadersDirectlyToObject","obj","headers","requestId","stripeAccount","apiVersion","idempotencyKey","_makeResponseEvent","requestEvent","statusCode","requestEndTime","Date","now","requestDurationMs","request_start_time","removeNullish","api_version","account","idempotency_key","method","path","status","request_id","_getRequestId","elapsed","request_end_time","_streamingResponseHandler","usage","callback","res","getHeaders","streamCompleteCallback","responseEvent","getStatusCode","_emitter","emit","_recordRequestMetrics","stream","toStream","_jsonResponseHandler","apiMode","toJSON","then","jsonResponse","error","err","type","message","error_description","StripeAuthenticationError","StripePermissionError","StripeRateLimitError","generateV2Error","generateV1Error","e","StripeAPIError","exception","rawResponse","getRawResponse","enumerable","writable","_generateConnectionErrorMessage","requestRetries","_shouldRetry","numRetries","maxRetries","HttpClient","CONNECTION_CLOSED_ERROR_CODES","includes","code","_getSleepTimeInMS","retryAfter","initialNetworkRetryDelay","getInitialNetworkRetryDelay","maxNetworkRetryDelay","getMaxNetworkRetryDelay","sleepSeconds","Math","min","pow","random","max","Number","isInteger","_getMaxNetworkRetries","settings","maxNetworkRetries","undefined","getMaxNetworkRetries","_defaultIdempotencyKey","genKey","_platformFunctions","uuid4","_makeHeaders","contentType","contentLength","clientUserAgent","userSuppliedHeaders","userSuppliedSettings","stripeContext","defaultHeaders","Accept","_getUserAgentString","_getTelemetryHeader","methodHasPayload","emitWarning","assign","normalizeHeaders","packageVersion","getConstant","appInfo","_appInfo","getAppInfoAsString","trim","getTelemetryEnabled","_prevRequestMetrics","length","metrics","shift","JSON","stringify","last_request_metrics","m","request_duration_ms","push","_rawRequest","params","options","requestPromise","Promise","resolve","reject","opts","requestMethod","toUpperCase","keys","Error","args","slice","call","dataFromArgs","getDataFromArgs","data","calculatedOptions","getOptionsFromArgs","authenticator","requestPath","bodyData","queryData","host","streaming","requestCallback","response","_request","requestDataProcessor","_a","requestData","_authenticator","getAPIMode","retryRequest","requestFn","setTimeout","makeRequest","timeout","getApiField","request","port","body","protocol","req","requestStartTime","catch","isTimeoutError","TIMEOUT_ERROR_CODE","StripeConnectionError","detail","StripeError","prepareAndMakeRequest","getClientUserAgent","stringifiedData","jsonStringifyRequestData","queryStringifyRequestData"],"sources":["C:/Users/saibh/OneDrive/Documents/bharath/client/node_modules/stripe/cjs/RequestSender.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RequestSender = void 0;\nconst Error_js_1 = require(\"./Error.js\");\nconst HttpClient_js_1 = require(\"./net/HttpClient.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst MAX_RETRY_AFTER_WAIT = 60;\nclass RequestSender {\n    constructor(stripe, maxBufferedRequestMetric) {\n        this._stripe = stripe;\n        this._maxBufferedRequestMetric = maxBufferedRequestMetric;\n    }\n    _addHeadersDirectlyToObject(obj, headers) {\n        // For convenience, make some headers easily accessible on\n        // lastResponse.\n        // NOTE: Stripe responds with lowercase header names/keys.\n        obj.requestId = headers['request-id'];\n        obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];\n        obj.apiVersion = obj.apiVersion || headers['stripe-version'];\n        obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];\n    }\n    _makeResponseEvent(requestEvent, statusCode, headers) {\n        const requestEndTime = Date.now();\n        const requestDurationMs = requestEndTime - requestEvent.request_start_time;\n        return (0, utils_js_1.removeNullish)({\n            api_version: headers['stripe-version'],\n            account: headers['stripe-account'],\n            idempotency_key: headers['idempotency-key'],\n            method: requestEvent.method,\n            path: requestEvent.path,\n            status: statusCode,\n            request_id: this._getRequestId(headers),\n            elapsed: requestDurationMs,\n            request_start_time: requestEvent.request_start_time,\n            request_end_time: requestEndTime,\n        });\n    }\n    _getRequestId(headers) {\n        return headers['request-id'];\n    }\n    /**\n     * Used by methods with spec.streaming === true. For these methods, we do not\n     * buffer successful responses into memory or do parse them into stripe\n     * objects, we delegate that all of that to the user and pass back the raw\n     * http.Response object to the callback.\n     *\n     * (Unsuccessful responses shouldn't make it here, they should\n     * still be buffered/parsed and handled by _jsonResponseHandler -- see\n     * makeRequest)\n     */\n    _streamingResponseHandler(requestEvent, usage, callback) {\n        return (res) => {\n            const headers = res.getHeaders();\n            const streamCompleteCallback = () => {\n                const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);\n                this._stripe._emitter.emit('response', responseEvent);\n                this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed, usage);\n            };\n            const stream = res.toStream(streamCompleteCallback);\n            // This is here for backwards compatibility, as the stream is a raw\n            // HTTP response in Node and the legacy behavior was to mutate this\n            // response.\n            this._addHeadersDirectlyToObject(stream, headers);\n            return callback(null, stream);\n        };\n    }\n    /**\n     * Default handler for Stripe responses. Buffers the response into memory,\n     * parses the JSON and returns it (i.e. passes it to the callback) if there\n     * is no \"error\" field. Otherwise constructs/passes an appropriate Error.\n     */\n    _jsonResponseHandler(requestEvent, apiMode, usage, callback) {\n        return (res) => {\n            const headers = res.getHeaders();\n            const requestId = this._getRequestId(headers);\n            const statusCode = res.getStatusCode();\n            const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);\n            this._stripe._emitter.emit('response', responseEvent);\n            res\n                .toJSON()\n                .then((jsonResponse) => {\n                if (jsonResponse.error) {\n                    let err;\n                    // Convert OAuth error responses into a standard format\n                    // so that the rest of the error logic can be shared\n                    if (typeof jsonResponse.error === 'string') {\n                        jsonResponse.error = {\n                            type: jsonResponse.error,\n                            message: jsonResponse.error_description,\n                        };\n                    }\n                    jsonResponse.error.headers = headers;\n                    jsonResponse.error.statusCode = statusCode;\n                    jsonResponse.error.requestId = requestId;\n                    if (statusCode === 401) {\n                        err = new Error_js_1.StripeAuthenticationError(jsonResponse.error);\n                    }\n                    else if (statusCode === 403) {\n                        err = new Error_js_1.StripePermissionError(jsonResponse.error);\n                    }\n                    else if (statusCode === 429) {\n                        err = new Error_js_1.StripeRateLimitError(jsonResponse.error);\n                    }\n                    else if (apiMode === 'v2') {\n                        err = (0, Error_js_1.generateV2Error)(jsonResponse.error);\n                    }\n                    else {\n                        err = (0, Error_js_1.generateV1Error)(jsonResponse.error);\n                    }\n                    throw err;\n                }\n                return jsonResponse;\n            }, (e) => {\n                throw new Error_js_1.StripeAPIError({\n                    message: 'Invalid JSON received from the Stripe API',\n                    exception: e,\n                    requestId: headers['request-id'],\n                });\n            })\n                .then((jsonResponse) => {\n                this._recordRequestMetrics(requestId, responseEvent.elapsed, usage);\n                // Expose raw response object.\n                const rawResponse = res.getRawResponse();\n                this._addHeadersDirectlyToObject(rawResponse, headers);\n                Object.defineProperty(jsonResponse, 'lastResponse', {\n                    enumerable: false,\n                    writable: false,\n                    value: rawResponse,\n                });\n                callback(null, jsonResponse);\n            }, (e) => callback(e, null));\n        };\n    }\n    static _generateConnectionErrorMessage(requestRetries) {\n        return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ''}`;\n    }\n    // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency\n    static _shouldRetry(res, numRetries, maxRetries, error) {\n        if (error &&\n            numRetries === 0 &&\n            HttpClient_js_1.HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {\n            return true;\n        }\n        // Do not retry if we are out of retries.\n        if (numRetries >= maxRetries) {\n            return false;\n        }\n        // Retry on connection error.\n        if (!res) {\n            return true;\n        }\n        // The API may ask us not to retry (e.g., if doing so would be a no-op)\n        // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.\n        if (res.getHeaders()['stripe-should-retry'] === 'false') {\n            return false;\n        }\n        if (res.getHeaders()['stripe-should-retry'] === 'true') {\n            return true;\n        }\n        // Retry on conflict errors.\n        if (res.getStatusCode() === 409) {\n            return true;\n        }\n        // Retry on 500, 503, and other internal errors.\n        //\n        // Note that we expect the stripe-should-retry header to be false\n        // in most cases when a 500 is returned, since our idempotency framework\n        // would typically replay it anyway.\n        if (res.getStatusCode() >= 500) {\n            return true;\n        }\n        return false;\n    }\n    _getSleepTimeInMS(numRetries, retryAfter = null) {\n        const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();\n        const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();\n        // Apply exponential backoff with initialNetworkRetryDelay on the\n        // number of numRetries so far as inputs. Do not allow the number to exceed\n        // maxNetworkRetryDelay.\n        let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(2, numRetries - 1), maxNetworkRetryDelay);\n        // Apply some jitter by randomizing the value in the range of\n        // (sleepSeconds / 2) to (sleepSeconds).\n        sleepSeconds *= 0.5 * (1 + Math.random());\n        // But never sleep less than the base sleep seconds.\n        sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);\n        // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n        if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {\n            sleepSeconds = Math.max(sleepSeconds, retryAfter);\n        }\n        return sleepSeconds * 1000;\n    }\n    // Max retries can be set on a per request basis. Favor those over the global setting\n    _getMaxNetworkRetries(settings = {}) {\n        return settings.maxNetworkRetries !== undefined &&\n            Number.isInteger(settings.maxNetworkRetries)\n            ? settings.maxNetworkRetries\n            : this._stripe.getMaxNetworkRetries();\n    }\n    _defaultIdempotencyKey(method, settings, apiMode) {\n        // If this is a POST and we allow multiple retries, ensure an idempotency key.\n        const maxRetries = this._getMaxNetworkRetries(settings);\n        const genKey = () => `stripe-node-retry-${this._stripe._platformFunctions.uuid4()}`;\n        // more verbose than it needs to be, but gives clear separation between V1 and V2 behavior\n        if (apiMode === 'v2') {\n            if (method === 'POST' || method === 'DELETE') {\n                return genKey();\n            }\n        }\n        else if (apiMode === 'v1') {\n            if (method === 'POST' && maxRetries > 0) {\n                return genKey();\n            }\n        }\n        return null;\n    }\n    _makeHeaders({ contentType, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings, stripeAccount, stripeContext, apiMode, }) {\n        const defaultHeaders = {\n            Accept: 'application/json',\n            'Content-Type': contentType,\n            'User-Agent': this._getUserAgentString(apiMode),\n            'X-Stripe-Client-User-Agent': clientUserAgent,\n            'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),\n            'Stripe-Version': apiVersion,\n            'Stripe-Account': stripeAccount,\n            'Stripe-Context': stripeContext,\n            'Idempotency-Key': this._defaultIdempotencyKey(method, userSuppliedSettings, apiMode),\n        };\n        // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:\n        //   A user agent SHOULD send a Content-Length in a request message when\n        //   no Transfer-Encoding is sent and the request method defines a meaning\n        //   for an enclosed payload body.  For example, a Content-Length header\n        //   field is normally sent in a POST request even when the value is 0\n        //   (indicating an empty payload body).  A user agent SHOULD NOT send a\n        //   Content-Length header field when the request message does not contain\n        //   a payload body and the method semantics do not anticipate such a\n        //   body.\n        //\n        // These method types are expected to have bodies and so we should always\n        // include a Content-Length.\n        const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n        // If a content length was specified, we always include it regardless of\n        // whether the method semantics anticipate such a body. This keeps us\n        // consistent with historical behavior. We do however want to warn on this\n        // and fix these cases as they are semantically incorrect.\n        if (methodHasPayload || contentLength) {\n            if (!methodHasPayload) {\n                (0, utils_js_1.emitWarning)(`${method} method had non-zero contentLength but no payload is expected for this verb`);\n            }\n            defaultHeaders['Content-Length'] = contentLength;\n        }\n        return Object.assign((0, utils_js_1.removeNullish)(defaultHeaders), \n        // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.\n        (0, utils_js_1.normalizeHeaders)(userSuppliedHeaders));\n    }\n    _getUserAgentString(apiMode) {\n        const packageVersion = this._stripe.getConstant('PACKAGE_VERSION');\n        const appInfo = this._stripe._appInfo\n            ? this._stripe.getAppInfoAsString()\n            : '';\n        return `Stripe/${apiMode} NodeBindings/${packageVersion} ${appInfo}`.trim();\n    }\n    _getTelemetryHeader() {\n        if (this._stripe.getTelemetryEnabled() &&\n            this._stripe._prevRequestMetrics.length > 0) {\n            const metrics = this._stripe._prevRequestMetrics.shift();\n            return JSON.stringify({\n                last_request_metrics: metrics,\n            });\n        }\n    }\n    _recordRequestMetrics(requestId, requestDurationMs, usage) {\n        if (this._stripe.getTelemetryEnabled() && requestId) {\n            if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {\n                (0, utils_js_1.emitWarning)('Request metrics buffer is full, dropping telemetry message.');\n            }\n            else {\n                const m = {\n                    request_id: requestId,\n                    request_duration_ms: requestDurationMs,\n                };\n                if (usage && usage.length > 0) {\n                    m.usage = usage;\n                }\n                this._stripe._prevRequestMetrics.push(m);\n            }\n        }\n    }\n    _rawRequest(method, path, params, options) {\n        const requestPromise = new Promise((resolve, reject) => {\n            let opts;\n            try {\n                const requestMethod = method.toUpperCase();\n                if (requestMethod !== 'POST' &&\n                    params &&\n                    Object.keys(params).length !== 0) {\n                    throw new Error('rawRequest only supports params on POST requests. Please pass null and add your parameters to path.');\n                }\n                const args = [].slice.call([params, options]);\n                // Pull request data and options (headers, auth) from args.\n                const dataFromArgs = (0, utils_js_1.getDataFromArgs)(args);\n                const data = Object.assign({}, dataFromArgs);\n                const calculatedOptions = (0, utils_js_1.getOptionsFromArgs)(args);\n                const headers = calculatedOptions.headers;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const authenticator = calculatedOptions.authenticator;\n                opts = {\n                    requestMethod,\n                    requestPath: path,\n                    bodyData: data,\n                    queryData: {},\n                    authenticator,\n                    headers,\n                    host: null,\n                    streaming: false,\n                    settings: {},\n                    usage: ['raw_request'],\n                };\n            }\n            catch (err) {\n                reject(err);\n                return;\n            }\n            function requestCallback(err, response) {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(response);\n                }\n            }\n            const { headers, settings } = opts;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const authenticator = opts.authenticator;\n            this._request(opts.requestMethod, opts.host, path, opts.bodyData, authenticator, { headers, settings, streaming: opts.streaming }, opts.usage, requestCallback);\n        });\n        return requestPromise;\n    }\n    _request(method, host, path, data, authenticator, options, usage = [], callback, requestDataProcessor = null) {\n        var _a;\n        let requestData;\n        authenticator = (_a = authenticator !== null && authenticator !== void 0 ? authenticator : this._stripe._authenticator) !== null && _a !== void 0 ? _a : null;\n        const apiMode = (0, utils_js_1.getAPIMode)(path);\n        const retryRequest = (requestFn, apiVersion, headers, requestRetries, retryAfter) => {\n            return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);\n        };\n        const makeRequest = (apiVersion, headers, numRetries) => {\n            // timeout can be set on a per-request basis. Favor that over the global setting\n            const timeout = options.settings &&\n                options.settings.timeout &&\n                Number.isInteger(options.settings.timeout) &&\n                options.settings.timeout >= 0\n                ? options.settings.timeout\n                : this._stripe.getApiField('timeout');\n            const request = {\n                host: host || this._stripe.getApiField('host'),\n                port: this._stripe.getApiField('port'),\n                path: path,\n                method: method,\n                headers: Object.assign({}, headers),\n                body: requestData,\n                protocol: this._stripe.getApiField('protocol'),\n            };\n            authenticator(request)\n                .then(() => {\n                const req = this._stripe\n                    .getApiField('httpClient')\n                    .makeRequest(request.host, request.port, request.path, request.method, request.headers, request.body, request.protocol, timeout);\n                const requestStartTime = Date.now();\n                // @ts-ignore\n                const requestEvent = (0, utils_js_1.removeNullish)({\n                    api_version: apiVersion,\n                    account: headers['Stripe-Account'],\n                    idempotency_key: headers['Idempotency-Key'],\n                    method,\n                    path,\n                    request_start_time: requestStartTime,\n                });\n                const requestRetries = numRetries || 0;\n                const maxRetries = this._getMaxNetworkRetries(options.settings || {});\n                this._stripe._emitter.emit('request', requestEvent);\n                req\n                    .then((res) => {\n                    if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {\n                        return retryRequest(makeRequest, apiVersion, headers, requestRetries, \n                        // @ts-ignore\n                        res.getHeaders()['retry-after']);\n                    }\n                    else if (options.streaming && res.getStatusCode() < 400) {\n                        return this._streamingResponseHandler(requestEvent, usage, callback)(res);\n                    }\n                    else {\n                        return this._jsonResponseHandler(requestEvent, apiMode, usage, callback)(res);\n                    }\n                })\n                    .catch((error) => {\n                    if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {\n                        return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);\n                    }\n                    else {\n                        const isTimeoutError = error.code && error.code === HttpClient_js_1.HttpClient.TIMEOUT_ERROR_CODE;\n                        return callback(new Error_js_1.StripeConnectionError({\n                            message: isTimeoutError\n                                ? `Request aborted due to timeout being reached (${timeout}ms)`\n                                : RequestSender._generateConnectionErrorMessage(requestRetries),\n                            // @ts-ignore\n                            detail: error,\n                        }));\n                    }\n                });\n            })\n                .catch((e) => {\n                throw new Error_js_1.StripeError({\n                    message: 'Unable to authenticate the request',\n                    exception: e,\n                });\n            });\n        };\n        const prepareAndMakeRequest = (error, data) => {\n            if (error) {\n                return callback(error);\n            }\n            requestData = data;\n            this._stripe.getClientUserAgent((clientUserAgent) => {\n                const apiVersion = this._stripe.getApiField('version');\n                const headers = this._makeHeaders({\n                    contentType: apiMode == 'v2'\n                        ? 'application/json'\n                        : 'application/x-www-form-urlencoded',\n                    contentLength: requestData.length,\n                    apiVersion: apiVersion,\n                    clientUserAgent,\n                    method,\n                    userSuppliedHeaders: options.headers,\n                    userSuppliedSettings: options.settings,\n                    stripeAccount: apiMode == 'v2' ? null : this._stripe.getApiField('stripeAccount'),\n                    stripeContext: apiMode == 'v2' ? this._stripe.getApiField('stripeContext') : null,\n                    apiMode: apiMode,\n                });\n                makeRequest(apiVersion, headers, 0);\n            });\n        };\n        if (requestDataProcessor) {\n            requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);\n        }\n        else {\n            let stringifiedData;\n            if (apiMode == 'v2') {\n                stringifiedData = data ? (0, utils_js_1.jsonStringifyRequestData)(data) : '';\n            }\n            else {\n                stringifiedData = (0, utils_js_1.queryStringifyRequestData)(data || {}, apiMode);\n            }\n            prepareAndMakeRequest(null, stringifiedData);\n        }\n    }\n}\nexports.RequestSender = RequestSender;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}