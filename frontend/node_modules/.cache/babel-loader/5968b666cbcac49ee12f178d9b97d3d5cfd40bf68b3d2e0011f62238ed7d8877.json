{"ast":null,"code":"\"use strict\";\n\nimport * as queryString from 'query-string';\nimport { getPatternParts } from \"./getPatternParts.js\";\nimport { validatePathConfig } from \"./validatePathConfig.js\";\nconst getActiveRoute = state => {\n  const route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n  return route;\n};\nconst cachedNormalizedConfigs = new WeakMap();\nconst getNormalizedConfigs = options => {\n  if (!options?.screens) return {};\n  const cached = cachedNormalizedConfigs.get(options?.screens);\n  if (cached) return cached;\n  const normalizedConfigs = createNormalizedConfigs(options.screens);\n  cachedNormalizedConfigs.set(options.screens, normalizedConfigs);\n  return normalizedConfigs;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport function getPathFromState(state, options) {\n  if (state == null) {\n    throw Error(`Got '${String(state)}' for the navigation state. You must pass a valid state object.`);\n  }\n  if (options) {\n    validatePathConfig(options);\n  }\n  const configs = getNormalizedConfigs(options);\n  let path = '/';\n  let current = state;\n  const allParams = {};\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index];\n    let parts;\n    let focusedParams;\n    let currentOptions = configs;\n    const focusedRoute = getActiveRoute(state);\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    const nestedRouteNames = [];\n    let hasNext = true;\n    while (route.name in currentOptions && hasNext) {\n      parts = currentOptions[route.name].parts;\n      nestedRouteNames.push(route.name);\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n        const currentParams = Object.fromEntries(Object.entries(route.params).map(([key, value]) => [key, stringify?.[key] ? stringify[key](value) : String(value)]));\n        if (parts?.length) {\n          Object.assign(allParams, currentParams);\n        }\n        if (focusedRoute === route) {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = {\n            ...currentParams\n          };\n          parts\n          // eslint-disable-next-line no-loop-func\n          ?.forEach(({\n            param\n          }) => {\n            if (param) {\n              // Remove the params present in the pattern since we'll only use the rest for query string\n              if (focusedParams) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete focusedParams[param];\n              }\n            }\n          });\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute;\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n    if (currentOptions[route.name] !== undefined) {\n      path += parts?.map(({\n        segment,\n        param,\n        optional\n      }) => {\n        // We don't know what to show for wildcard patterns\n        // Showing the route name seems ok, though whatever we show here will be incorrect\n        // Since the page doesn't actually exist\n        if (segment === '*') {\n          return route.name;\n        }\n\n        // If the path has a pattern for a param, put the param in the path\n        if (param) {\n          const value = allParams[param];\n          if (value === undefined && optional) {\n            // Optional params without value assigned in route.params should be ignored\n            return '';\n          }\n\n          // Valid characters according to\n          // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)\n          return String(value).replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g, char => encodeURIComponent(char));\n        }\n        return encodeURIComponent(segment);\n      }).join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n    if (!focusedParams && focusedRoute.params) {\n      focusedParams = Object.fromEntries(Object.entries(focusedRoute.params).map(([key, value]) => [key, String(value)]));\n    }\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (const param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n      const query = queryString.stringify(focusedParams, {\n        sort: false\n      });\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n    current = route.state;\n  }\n\n  // Include the root path if specified\n  if (options?.path) {\n    path = `${options.path}/${path}`;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  // If path doesn't start with a slash, add it\n  // This makes sure that history.pushState will update the path correctly instead of appending\n  if (!path.startsWith('/')) {\n    path = `/${path}`;\n  }\n  return path;\n}\nconst createConfigItem = (config, parentParts) => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const parts = getPatternParts(config);\n    if (parentParts) {\n      return {\n        parts: [...parentParts, ...parts]\n      };\n    }\n    return {\n      parts\n    };\n  }\n  if (config.exact && config.path === undefined) {\n    throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  const parts = config.exact !== true ? [...(parentParts || []), ...(config.path ? getPatternParts(config.path) : [])] : config.path ? getPatternParts(config.path) : undefined;\n  const screens = config.screens ? createNormalizedConfigs(config.screens, parts) : undefined;\n  return {\n    parts,\n    stringify: config.stringify,\n    screens\n  };\n};\nconst createNormalizedConfigs = (options, parts) => Object.fromEntries(Object.entries(options).map(([name, c]) => {\n  const result = createConfigItem(c, parts);\n  return [name, result];\n}));","map":{"version":3,"names":["queryString","getPatternParts","validatePathConfig","getActiveRoute","state","route","index","routes","length","cachedNormalizedConfigs","WeakMap","getNormalizedConfigs","options","screens","cached","get","normalizedConfigs","createNormalizedConfigs","set","getPathFromState","Error","String","configs","path","current","allParams","parts","focusedParams","currentOptions","focusedRoute","nestedRouteNames","hasNext","name","push","params","stringify","currentParams","Object","fromEntries","entries","map","key","value","assign","forEach","param","undefined","nextRoute","nestedConfig","segment","optional","replace","char","encodeURIComponent","join","query","sort","startsWith","createConfigItem","config","parentParts","exact","c","result"],"sources":["C:\\Users\\saibh\\OneDrive\\Documents\\bharath\\Lets_do_it\\client\\node_modules\\@react-navigation\\core\\src\\getPathFromState.tsx"],"sourcesContent":["import type {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\nimport * as queryString from 'query-string';\n\nimport { getPatternParts, type PatternPart } from './getPatternParts';\nimport type { PathConfig, PathConfigMap } from './types';\nimport { validatePathConfig } from './validatePathConfig';\n\ntype Options<ParamList extends {}> = {\n  path?: string;\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: unknown) => string>;\n\ntype ConfigItem = {\n  parts?: PatternPart[];\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\nconst cachedNormalizedConfigs = new WeakMap<\n  PathConfigMap<{}>,\n  Record<string, ConfigItem>\n>();\n\nconst getNormalizedConfigs = (options?: Options<{}>) => {\n  if (!options?.screens) return {};\n\n  const cached = cachedNormalizedConfigs.get(options?.screens);\n\n  if (cached) return cached;\n\n  const normalizedConfigs = createNormalizedConfigs(options.screens);\n\n  cachedNormalizedConfigs.set(options.screens, normalizedConfigs);\n\n  return normalizedConfigs;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport function getPathFromState<ParamList extends {}>(\n  state: State,\n  options?: Options<ParamList>\n): string {\n  if (state == null) {\n    throw Error(\n      `Got '${String(state)}' for the navigation state. You must pass a valid state object.`\n    );\n  }\n\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const configs = getNormalizedConfigs(options);\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, string> = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let parts: PatternPart[] | undefined;\n\n    let focusedParams: Record<string, string> | undefined;\n    let currentOptions = configs;\n\n    const focusedRoute = getActiveRoute(state);\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    const nestedRouteNames = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      parts = currentOptions[route.name].parts;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n\n        const currentParams = Object.fromEntries(\n          Object.entries(route.params).map(([key, value]) => [\n            key,\n            stringify?.[key] ? stringify[key](value) : String(value),\n          ])\n        );\n\n        if (parts?.length) {\n          Object.assign(allParams, currentParams);\n        }\n\n        if (focusedRoute === route) {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = { ...currentParams };\n\n          parts\n            // eslint-disable-next-line no-loop-func\n            ?.forEach(({ param }) => {\n              if (param) {\n                // Remove the params present in the pattern since we'll only use the rest for query string\n                if (focusedParams) {\n                  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                  delete focusedParams[param];\n                }\n              }\n            });\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index =\n          typeof route.state.index === 'number'\n            ? route.state.index\n            : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += parts\n        ?.map(({ segment, param, optional }) => {\n          // We don't know what to show for wildcard patterns\n          // Showing the route name seems ok, though whatever we show here will be incorrect\n          // Since the page doesn't actually exist\n          if (segment === '*') {\n            return route.name;\n          }\n\n          // If the path has a pattern for a param, put the param in the path\n          if (param) {\n            const value = allParams[param];\n\n            if (value === undefined && optional) {\n              // Optional params without value assigned in route.params should be ignored\n              return '';\n            }\n\n            // Valid characters according to\n            // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)\n            return String(value).replace(\n              /[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g,\n              (char) => encodeURIComponent(char)\n            );\n          }\n\n          return encodeURIComponent(segment);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams && focusedRoute.params) {\n      focusedParams = Object.fromEntries(\n        Object.entries(focusedRoute.params).map(([key, value]) => [\n          key,\n          String(value),\n        ])\n      );\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (const param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n\n      const query = queryString.stringify(focusedParams, { sort: false });\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Include the root path if specified\n  if (options?.path) {\n    path = `${options.path}/${path}`;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  // If path doesn't start with a slash, add it\n  // This makes sure that history.pushState will update the path correctly instead of appending\n  if (!path.startsWith('/')) {\n    path = `/${path}`;\n  }\n\n  return path;\n}\n\nconst createConfigItem = (\n  config: PathConfig<object> | string,\n  parentParts?: PatternPart[]\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const parts = getPatternParts(config);\n\n    if (parentParts) {\n      return { parts: [...parentParts, ...parts] };\n    }\n\n    return { parts };\n  }\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n    );\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  const parts =\n    config.exact !== true\n      ? [\n          ...(parentParts || []),\n          ...(config.path ? getPatternParts(config.path) : []),\n        ]\n      : config.path\n        ? getPatternParts(config.path)\n        : undefined;\n\n  const screens = config.screens\n    ? createNormalizedConfigs(config.screens, parts)\n    : undefined;\n\n  return {\n    parts,\n    stringify: config.stringify,\n    screens,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfigMap<object>,\n  parts?: PatternPart[]\n): Record<string, ConfigItem> =>\n  Object.fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(c, parts);\n\n      return [name, result];\n    })\n  );\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}