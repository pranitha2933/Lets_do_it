{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createWebhooks = void 0;\nconst Error_js_1 = require(\"./Error.js\");\nconst CryptoProvider_js_1 = require(\"./crypto/CryptoProvider.js\");\nfunction createWebhooks(platformFunctions) {\n  const Webhook = {\n    DEFAULT_TOLERANCE: 300,\n    // @ts-ignore\n    signature: null,\n    constructEvent(payload, header, secret, tolerance, cryptoProvider, receivedAt) {\n      try {\n        this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider, receivedAt);\n      } catch (e) {\n        if (e instanceof CryptoProvider_js_1.CryptoProviderOnlySupportsAsyncError) {\n          e.message += '\\nUse `await constructEventAsync(...)` instead of `constructEvent(...)`';\n        }\n        throw e;\n      }\n      const jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder('utf8').decode(payload)) : JSON.parse(payload);\n      return jsonPayload;\n    },\n    async constructEventAsync(payload, header, secret, tolerance, cryptoProvider, receivedAt) {\n      await this.signature.verifyHeaderAsync(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider, receivedAt);\n      const jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder('utf8').decode(payload)) : JSON.parse(payload);\n      return jsonPayload;\n    },\n    /**\n     * Generates a header to be used for webhook mocking\n     *\n     * @typedef {object} opts\n     * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()\n     * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters\n     * @property {string} secret - Stripe webhook secret 'whsec_...'\n     * @property {string} scheme - Version of API to hit. Defaults to 'v1'.\n     * @property {string} signature - Computed webhook signature\n     * @property {CryptoProvider} cryptoProvider - Crypto provider to use for computing the signature if none was provided. Defaults to NodeCryptoProvider.\n     */\n    generateTestHeaderString: function (opts) {\n      const preparedOpts = prepareOptions(opts);\n      const signature = preparedOpts.signature || preparedOpts.cryptoProvider.computeHMACSignature(preparedOpts.payloadString, preparedOpts.secret);\n      return preparedOpts.generateHeaderString(signature);\n    },\n    generateTestHeaderStringAsync: async function (opts) {\n      const preparedOpts = prepareOptions(opts);\n      const signature = preparedOpts.signature || (await preparedOpts.cryptoProvider.computeHMACSignatureAsync(preparedOpts.payloadString, preparedOpts.secret));\n      return preparedOpts.generateHeaderString(signature);\n    }\n  };\n  const signature = {\n    EXPECTED_SCHEME: 'v1',\n    verifyHeader(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider, receivedAt) {\n      const {\n        decodedHeader: header,\n        decodedPayload: payload,\n        details,\n        suspectPayloadType\n      } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n      const secretContainsWhitespace = /\\s/.test(secret);\n      cryptoProvider = cryptoProvider || getCryptoProvider();\n      const expectedSignature = cryptoProvider.computeHMACSignature(makeHMACContent(payload, details), secret);\n      validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt);\n      return true;\n    },\n    async verifyHeaderAsync(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider, receivedAt) {\n      const {\n        decodedHeader: header,\n        decodedPayload: payload,\n        details,\n        suspectPayloadType\n      } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n      const secretContainsWhitespace = /\\s/.test(secret);\n      cryptoProvider = cryptoProvider || getCryptoProvider();\n      const expectedSignature = await cryptoProvider.computeHMACSignatureAsync(makeHMACContent(payload, details), secret);\n      return validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt);\n    }\n  };\n  function makeHMACContent(payload, details) {\n    return `${details.timestamp}.${payload}`;\n  }\n  function parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {\n    if (!encodedPayload) {\n      throw new Error_js_1.StripeSignatureVerificationError(encodedHeader, encodedPayload, {\n        message: 'No webhook payload was provided.'\n      });\n    }\n    const suspectPayloadType = typeof encodedPayload != 'string' && !(encodedPayload instanceof Uint8Array);\n    const textDecoder = new TextDecoder('utf8');\n    const decodedPayload = encodedPayload instanceof Uint8Array ? textDecoder.decode(encodedPayload) : encodedPayload;\n    // Express's type for `Request#headers` is `string | []string`\n    // which is because the `set-cookie` header is an array,\n    // but no other headers are an array (docs: https://nodejs.org/api/http.html#http_message_headers)\n    // (Express's Request class is an extension of http.IncomingMessage, and doesn't appear to be relevantly modified: https://github.com/expressjs/express/blob/master/lib/request.js#L31)\n    if (Array.isArray(encodedHeader)) {\n      throw new Error('Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.');\n    }\n    if (encodedHeader == null || encodedHeader == '') {\n      throw new Error_js_1.StripeSignatureVerificationError(encodedHeader, encodedPayload, {\n        message: 'No stripe-signature header value was provided.'\n      });\n    }\n    const decodedHeader = encodedHeader instanceof Uint8Array ? textDecoder.decode(encodedHeader) : encodedHeader;\n    const details = parseHeader(decodedHeader, expectedScheme);\n    if (!details || details.timestamp === -1) {\n      throw new Error_js_1.StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n        message: 'Unable to extract timestamp and signatures from header'\n      });\n    }\n    if (!details.signatures.length) {\n      throw new Error_js_1.StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n        message: 'No signatures found with expected scheme'\n      });\n    }\n    return {\n      decodedPayload,\n      decodedHeader,\n      details,\n      suspectPayloadType\n    };\n  }\n  function validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt) {\n    const signatureFound = !!details.signatures.filter(platformFunctions.secureCompare.bind(platformFunctions, expectedSignature)).length;\n    const docsLocation = '\\nLearn more about webhook signing and explore webhook integration examples for various frameworks at ' + 'https://docs.stripe.com/webhooks/signature';\n    const whitespaceMessage = secretContainsWhitespace ? '\\n\\nNote: The provided signing secret contains whitespace. This often indicates an extra newline or space is in the value' : '';\n    if (!signatureFound) {\n      if (suspectPayloadType) {\n        throw new Error_js_1.StripeSignatureVerificationError(header, payload, {\n          message: 'Webhook payload must be provided as a string or a Buffer (https://nodejs.org/api/buffer.html) instance representing the _raw_ request body.' + 'Payload was provided as a parsed JavaScript object instead. \\n' + 'Signature verification is impossible without access to the original signed material. \\n' + docsLocation + '\\n' + whitespaceMessage\n        });\n      }\n      throw new Error_js_1.StripeSignatureVerificationError(header, payload, {\n        message: 'No signatures found matching the expected signature for payload.' + ' Are you passing the raw request body you received from Stripe? \\n' + ' If a webhook request is being forwarded by a third-party tool,' + ' ensure that the exact request body, including JSON formatting and new line style, is preserved.\\n' + docsLocation + '\\n' + whitespaceMessage\n      });\n    }\n    const timestampAge = Math.floor((typeof receivedAt === 'number' ? receivedAt : Date.now()) / 1000) - details.timestamp;\n    if (tolerance > 0 && timestampAge > tolerance) {\n      // @ts-ignore\n      throw new Error_js_1.StripeSignatureVerificationError(header, payload, {\n        message: 'Timestamp outside the tolerance zone'\n      });\n    }\n    return true;\n  }\n  function parseHeader(header, scheme) {\n    if (typeof header !== 'string') {\n      return null;\n    }\n    return header.split(',').reduce((accum, item) => {\n      const kv = item.split('=');\n      if (kv[0] === 't') {\n        accum.timestamp = parseInt(kv[1], 10);\n      }\n      if (kv[0] === scheme) {\n        accum.signatures.push(kv[1]);\n      }\n      return accum;\n    }, {\n      timestamp: -1,\n      signatures: []\n    });\n  }\n  let webhooksCryptoProviderInstance = null;\n  /**\n   * Lazily instantiate a CryptoProvider instance. This is a stateless object\n   * so a singleton can be used here.\n   */\n  function getCryptoProvider() {\n    if (!webhooksCryptoProviderInstance) {\n      webhooksCryptoProviderInstance = platformFunctions.createDefaultCryptoProvider();\n    }\n    return webhooksCryptoProviderInstance;\n  }\n  function prepareOptions(opts) {\n    if (!opts) {\n      throw new Error_js_1.StripeError({\n        message: 'Options are required'\n      });\n    }\n    const timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);\n    const scheme = opts.scheme || signature.EXPECTED_SCHEME;\n    const cryptoProvider = opts.cryptoProvider || getCryptoProvider();\n    const payloadString = `${timestamp}.${opts.payload}`;\n    const generateHeaderString = signature => {\n      return `t=${timestamp},${scheme}=${signature}`;\n    };\n    return Object.assign(Object.assign({}, opts), {\n      timestamp,\n      scheme,\n      cryptoProvider,\n      payloadString,\n      generateHeaderString\n    });\n  }\n  Webhook.signature = signature;\n  return Webhook;\n}\nexports.createWebhooks = createWebhooks;","map":{"version":3,"names":["Object","defineProperty","exports","value","createWebhooks","Error_js_1","require","CryptoProvider_js_1","platformFunctions","Webhook","DEFAULT_TOLERANCE","signature","constructEvent","payload","header","secret","tolerance","cryptoProvider","receivedAt","verifyHeader","e","CryptoProviderOnlySupportsAsyncError","message","jsonPayload","Uint8Array","JSON","parse","TextDecoder","decode","constructEventAsync","verifyHeaderAsync","generateTestHeaderString","opts","preparedOpts","prepareOptions","computeHMACSignature","payloadString","generateHeaderString","generateTestHeaderStringAsync","computeHMACSignatureAsync","EXPECTED_SCHEME","encodedPayload","encodedHeader","decodedHeader","decodedPayload","details","suspectPayloadType","parseEventDetails","secretContainsWhitespace","test","getCryptoProvider","expectedSignature","makeHMACContent","validateComputedSignature","timestamp","expectedScheme","StripeSignatureVerificationError","textDecoder","Array","isArray","Error","parseHeader","signatures","length","signatureFound","filter","secureCompare","bind","docsLocation","whitespaceMessage","timestampAge","Math","floor","Date","now","scheme","split","reduce","accum","item","kv","parseInt","push","webhooksCryptoProviderInstance","createDefaultCryptoProvider","StripeError","assign"],"sources":["C:/Users/saibh/OneDrive/Documents/bharath/client/node_modules/stripe/cjs/Webhooks.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createWebhooks = void 0;\nconst Error_js_1 = require(\"./Error.js\");\nconst CryptoProvider_js_1 = require(\"./crypto/CryptoProvider.js\");\nfunction createWebhooks(platformFunctions) {\n    const Webhook = {\n        DEFAULT_TOLERANCE: 300,\n        // @ts-ignore\n        signature: null,\n        constructEvent(payload, header, secret, tolerance, cryptoProvider, receivedAt) {\n            try {\n                this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider, receivedAt);\n            }\n            catch (e) {\n                if (e instanceof CryptoProvider_js_1.CryptoProviderOnlySupportsAsyncError) {\n                    e.message +=\n                        '\\nUse `await constructEventAsync(...)` instead of `constructEvent(...)`';\n                }\n                throw e;\n            }\n            const jsonPayload = payload instanceof Uint8Array\n                ? JSON.parse(new TextDecoder('utf8').decode(payload))\n                : JSON.parse(payload);\n            return jsonPayload;\n        },\n        async constructEventAsync(payload, header, secret, tolerance, cryptoProvider, receivedAt) {\n            await this.signature.verifyHeaderAsync(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider, receivedAt);\n            const jsonPayload = payload instanceof Uint8Array\n                ? JSON.parse(new TextDecoder('utf8').decode(payload))\n                : JSON.parse(payload);\n            return jsonPayload;\n        },\n        /**\n         * Generates a header to be used for webhook mocking\n         *\n         * @typedef {object} opts\n         * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()\n         * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters\n         * @property {string} secret - Stripe webhook secret 'whsec_...'\n         * @property {string} scheme - Version of API to hit. Defaults to 'v1'.\n         * @property {string} signature - Computed webhook signature\n         * @property {CryptoProvider} cryptoProvider - Crypto provider to use for computing the signature if none was provided. Defaults to NodeCryptoProvider.\n         */\n        generateTestHeaderString: function (opts) {\n            const preparedOpts = prepareOptions(opts);\n            const signature = preparedOpts.signature ||\n                preparedOpts.cryptoProvider.computeHMACSignature(preparedOpts.payloadString, preparedOpts.secret);\n            return preparedOpts.generateHeaderString(signature);\n        },\n        generateTestHeaderStringAsync: async function (opts) {\n            const preparedOpts = prepareOptions(opts);\n            const signature = preparedOpts.signature ||\n                (await preparedOpts.cryptoProvider.computeHMACSignatureAsync(preparedOpts.payloadString, preparedOpts.secret));\n            return preparedOpts.generateHeaderString(signature);\n        },\n    };\n    const signature = {\n        EXPECTED_SCHEME: 'v1',\n        verifyHeader(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider, receivedAt) {\n            const { decodedHeader: header, decodedPayload: payload, details, suspectPayloadType, } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n            const secretContainsWhitespace = /\\s/.test(secret);\n            cryptoProvider = cryptoProvider || getCryptoProvider();\n            const expectedSignature = cryptoProvider.computeHMACSignature(makeHMACContent(payload, details), secret);\n            validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt);\n            return true;\n        },\n        async verifyHeaderAsync(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider, receivedAt) {\n            const { decodedHeader: header, decodedPayload: payload, details, suspectPayloadType, } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n            const secretContainsWhitespace = /\\s/.test(secret);\n            cryptoProvider = cryptoProvider || getCryptoProvider();\n            const expectedSignature = await cryptoProvider.computeHMACSignatureAsync(makeHMACContent(payload, details), secret);\n            return validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt);\n        },\n    };\n    function makeHMACContent(payload, details) {\n        return `${details.timestamp}.${payload}`;\n    }\n    function parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {\n        if (!encodedPayload) {\n            throw new Error_js_1.StripeSignatureVerificationError(encodedHeader, encodedPayload, {\n                message: 'No webhook payload was provided.',\n            });\n        }\n        const suspectPayloadType = typeof encodedPayload != 'string' &&\n            !(encodedPayload instanceof Uint8Array);\n        const textDecoder = new TextDecoder('utf8');\n        const decodedPayload = encodedPayload instanceof Uint8Array\n            ? textDecoder.decode(encodedPayload)\n            : encodedPayload;\n        // Express's type for `Request#headers` is `string | []string`\n        // which is because the `set-cookie` header is an array,\n        // but no other headers are an array (docs: https://nodejs.org/api/http.html#http_message_headers)\n        // (Express's Request class is an extension of http.IncomingMessage, and doesn't appear to be relevantly modified: https://github.com/expressjs/express/blob/master/lib/request.js#L31)\n        if (Array.isArray(encodedHeader)) {\n            throw new Error('Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.');\n        }\n        if (encodedHeader == null || encodedHeader == '') {\n            throw new Error_js_1.StripeSignatureVerificationError(encodedHeader, encodedPayload, {\n                message: 'No stripe-signature header value was provided.',\n            });\n        }\n        const decodedHeader = encodedHeader instanceof Uint8Array\n            ? textDecoder.decode(encodedHeader)\n            : encodedHeader;\n        const details = parseHeader(decodedHeader, expectedScheme);\n        if (!details || details.timestamp === -1) {\n            throw new Error_js_1.StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n                message: 'Unable to extract timestamp and signatures from header',\n            });\n        }\n        if (!details.signatures.length) {\n            throw new Error_js_1.StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n                message: 'No signatures found with expected scheme',\n            });\n        }\n        return {\n            decodedPayload,\n            decodedHeader,\n            details,\n            suspectPayloadType,\n        };\n    }\n    function validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt) {\n        const signatureFound = !!details.signatures.filter(platformFunctions.secureCompare.bind(platformFunctions, expectedSignature)).length;\n        const docsLocation = '\\nLearn more about webhook signing and explore webhook integration examples for various frameworks at ' +\n            'https://docs.stripe.com/webhooks/signature';\n        const whitespaceMessage = secretContainsWhitespace\n            ? '\\n\\nNote: The provided signing secret contains whitespace. This often indicates an extra newline or space is in the value'\n            : '';\n        if (!signatureFound) {\n            if (suspectPayloadType) {\n                throw new Error_js_1.StripeSignatureVerificationError(header, payload, {\n                    message: 'Webhook payload must be provided as a string or a Buffer (https://nodejs.org/api/buffer.html) instance representing the _raw_ request body.' +\n                        'Payload was provided as a parsed JavaScript object instead. \\n' +\n                        'Signature verification is impossible without access to the original signed material. \\n' +\n                        docsLocation +\n                        '\\n' +\n                        whitespaceMessage,\n                });\n            }\n            throw new Error_js_1.StripeSignatureVerificationError(header, payload, {\n                message: 'No signatures found matching the expected signature for payload.' +\n                    ' Are you passing the raw request body you received from Stripe? \\n' +\n                    ' If a webhook request is being forwarded by a third-party tool,' +\n                    ' ensure that the exact request body, including JSON formatting and new line style, is preserved.\\n' +\n                    docsLocation +\n                    '\\n' +\n                    whitespaceMessage,\n            });\n        }\n        const timestampAge = Math.floor((typeof receivedAt === 'number' ? receivedAt : Date.now()) / 1000) - details.timestamp;\n        if (tolerance > 0 && timestampAge > tolerance) {\n            // @ts-ignore\n            throw new Error_js_1.StripeSignatureVerificationError(header, payload, {\n                message: 'Timestamp outside the tolerance zone',\n            });\n        }\n        return true;\n    }\n    function parseHeader(header, scheme) {\n        if (typeof header !== 'string') {\n            return null;\n        }\n        return header.split(',').reduce((accum, item) => {\n            const kv = item.split('=');\n            if (kv[0] === 't') {\n                accum.timestamp = parseInt(kv[1], 10);\n            }\n            if (kv[0] === scheme) {\n                accum.signatures.push(kv[1]);\n            }\n            return accum;\n        }, {\n            timestamp: -1,\n            signatures: [],\n        });\n    }\n    let webhooksCryptoProviderInstance = null;\n    /**\n     * Lazily instantiate a CryptoProvider instance. This is a stateless object\n     * so a singleton can be used here.\n     */\n    function getCryptoProvider() {\n        if (!webhooksCryptoProviderInstance) {\n            webhooksCryptoProviderInstance = platformFunctions.createDefaultCryptoProvider();\n        }\n        return webhooksCryptoProviderInstance;\n    }\n    function prepareOptions(opts) {\n        if (!opts) {\n            throw new Error_js_1.StripeError({\n                message: 'Options are required',\n            });\n        }\n        const timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);\n        const scheme = opts.scheme || signature.EXPECTED_SCHEME;\n        const cryptoProvider = opts.cryptoProvider || getCryptoProvider();\n        const payloadString = `${timestamp}.${opts.payload}`;\n        const generateHeaderString = (signature) => {\n            return `t=${timestamp},${scheme}=${signature}`;\n        };\n        return Object.assign(Object.assign({}, opts), { timestamp,\n            scheme,\n            cryptoProvider,\n            payloadString,\n            generateHeaderString });\n    }\n    Webhook.signature = signature;\n    return Webhook;\n}\nexports.createWebhooks = createWebhooks;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}