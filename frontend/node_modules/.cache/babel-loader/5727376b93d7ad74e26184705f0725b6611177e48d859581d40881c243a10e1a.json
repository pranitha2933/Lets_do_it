{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeAutoPaginationMethods = void 0;\nconst utils_js_1 = require(\"./utils.js\");\nclass V1Iterator {\n  constructor(firstPagePromise, requestArgs, spec, stripeResource) {\n    this.index = 0;\n    this.pagePromise = firstPagePromise;\n    this.promiseCache = {\n      currentPromise: null\n    };\n    this.requestArgs = requestArgs;\n    this.spec = spec;\n    this.stripeResource = stripeResource;\n  }\n  async iterate(pageResult) {\n    if (!(pageResult && pageResult.data && typeof pageResult.data.length === 'number')) {\n      throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n    }\n    const reverseIteration = isReverseIteration(this.requestArgs);\n    if (this.index < pageResult.data.length) {\n      const idx = reverseIteration ? pageResult.data.length - 1 - this.index : this.index;\n      const value = pageResult.data[idx];\n      this.index += 1;\n      return {\n        value,\n        done: false\n      };\n    } else if (pageResult.has_more) {\n      // Reset counter, request next page, and recurse.\n      this.index = 0;\n      this.pagePromise = this.getNextPage(pageResult);\n      const nextPageResult = await this.pagePromise;\n      return this.iterate(nextPageResult);\n    }\n    return {\n      done: true,\n      value: undefined\n    };\n  }\n  /** @abstract */\n  getNextPage(_pageResult) {\n    throw new Error('Unimplemented');\n  }\n  async _next() {\n    return this.iterate(await this.pagePromise);\n  }\n  next() {\n    /**\n     * If a user calls `.next()` multiple times in parallel,\n     * return the same result until something has resolved\n     * to prevent page-turning race conditions.\n     */\n    if (this.promiseCache.currentPromise) {\n      return this.promiseCache.currentPromise;\n    }\n    const nextPromise = (async () => {\n      const ret = await this._next();\n      this.promiseCache.currentPromise = null;\n      return ret;\n    })();\n    this.promiseCache.currentPromise = nextPromise;\n    return nextPromise;\n  }\n}\nclass V1ListIterator extends V1Iterator {\n  getNextPage(pageResult) {\n    const reverseIteration = isReverseIteration(this.requestArgs);\n    const lastId = getLastId(pageResult, reverseIteration);\n    return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n      [reverseIteration ? 'ending_before' : 'starting_after']: lastId\n    });\n  }\n}\nclass V1SearchIterator extends V1Iterator {\n  getNextPage(pageResult) {\n    if (!pageResult.next_page) {\n      throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');\n    }\n    return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n      page: pageResult.next_page\n    });\n  }\n}\nclass V2ListIterator {\n  constructor(firstPagePromise, requestArgs, spec, stripeResource) {\n    this.currentPageIterator = (async () => {\n      const page = await firstPagePromise;\n      return page.data[Symbol.iterator]();\n    })();\n    this.nextPageUrl = (async () => {\n      const page = await firstPagePromise;\n      return page.next_page_url || null;\n    })();\n    this.requestArgs = requestArgs;\n    this.spec = spec;\n    this.stripeResource = stripeResource;\n  }\n  async turnPage() {\n    const nextPageUrl = await this.nextPageUrl;\n    if (!nextPageUrl) return null;\n    this.spec.fullPath = nextPageUrl;\n    const page = await this.stripeResource._makeRequest([], this.spec, {});\n    this.nextPageUrl = Promise.resolve(page.next_page_url);\n    this.currentPageIterator = Promise.resolve(page.data[Symbol.iterator]());\n    return this.currentPageIterator;\n  }\n  async next() {\n    {\n      const result = (await this.currentPageIterator).next();\n      if (!result.done) return {\n        done: false,\n        value: result.value\n      };\n    }\n    const nextPageIterator = await this.turnPage();\n    if (!nextPageIterator) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    const result = nextPageIterator.next();\n    if (!result.done) return {\n      done: false,\n      value: result.value\n    };\n    return {\n      done: true,\n      value: undefined\n    };\n  }\n}\nconst makeAutoPaginationMethods = (stripeResource, requestArgs, spec, firstPagePromise) => {\n  const apiMode = (0, utils_js_1.getAPIMode)(spec.fullPath || spec.path);\n  if (apiMode !== 'v2' && spec.methodType === 'search') {\n    return makeAutoPaginationMethodsFromIterator(new V1SearchIterator(firstPagePromise, requestArgs, spec, stripeResource));\n  }\n  if (apiMode !== 'v2' && spec.methodType === 'list') {\n    return makeAutoPaginationMethodsFromIterator(new V1ListIterator(firstPagePromise, requestArgs, spec, stripeResource));\n  }\n  if (apiMode === 'v2' && spec.methodType === 'list') {\n    return makeAutoPaginationMethodsFromIterator(new V2ListIterator(firstPagePromise, requestArgs, spec, stripeResource));\n  }\n  return null;\n};\nexports.makeAutoPaginationMethods = makeAutoPaginationMethods;\nconst makeAutoPaginationMethodsFromIterator = iterator => {\n  const autoPagingEach = makeAutoPagingEach((...args) => iterator.next(...args));\n  const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n  const autoPaginationMethods = {\n    autoPagingEach,\n    autoPagingToArray,\n    // Async iterator functions:\n    next: () => iterator.next(),\n    return: () => {\n      // This is required for `break`.\n      return {};\n    },\n    [getAsyncIteratorSymbol()]: () => {\n      return autoPaginationMethods;\n    }\n  };\n  return autoPaginationMethods;\n};\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\nfunction getAsyncIteratorSymbol() {\n  if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n    return Symbol.asyncIterator;\n  }\n  // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n  return '@@asyncIterator';\n}\nfunction getDoneCallback(args) {\n  if (args.length < 2) {\n    return null;\n  }\n  const onDone = args[1];\n  if (typeof onDone !== 'function') {\n    throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);\n  }\n  return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\nfunction getItemCallback(args) {\n  if (args.length === 0) {\n    return undefined;\n  }\n  const onItem = args[0];\n  if (typeof onItem !== 'function') {\n    throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);\n  }\n  // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n  if (onItem.length === 2) {\n    return onItem;\n  }\n  if (onItem.length > 2) {\n    throw Error(`The \\`onItem\\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);\n  }\n  // This magically handles all three of these usecases (the latter two being functionally identical):\n  // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n  // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n  // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n  return function _onItem(item, next) {\n    const shouldContinue = onItem(item);\n    next(shouldContinue);\n  };\n}\nfunction getLastId(listResult, reverseIteration) {\n  const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n  const lastItem = listResult.data[lastIdx];\n  const lastId = lastItem && lastItem.id;\n  if (!lastId) {\n    throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n  }\n  return lastId;\n}\nfunction makeAutoPagingEach(asyncIteratorNext) {\n  return function autoPagingEach(/* onItem?, onDone? */\n  ) {\n    const args = [].slice.call(arguments);\n    const onItem = getItemCallback(args);\n    const onDone = getDoneCallback(args);\n    if (args.length > 2) {\n      throw Error(`autoPagingEach takes up to two arguments; received ${args}`);\n    }\n    const autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext,\n    // @ts-ignore we might need a null check\n    onItem);\n    return (0, utils_js_1.callbackifyPromiseWithTimeout)(autoPagePromise, onDone);\n  };\n}\nfunction makeAutoPagingToArray(autoPagingEach) {\n  return function autoPagingToArray(opts, onDone) {\n    const limit = opts && opts.limit;\n    if (!limit) {\n      throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');\n    }\n    if (limit > 10000) {\n      throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n    }\n    const promise = new Promise((resolve, reject) => {\n      const items = [];\n      autoPagingEach(item => {\n        items.push(item);\n        if (items.length >= limit) {\n          return false;\n        }\n      }).then(() => {\n        resolve(items);\n      }).catch(reject);\n    });\n    // @ts-ignore\n    return (0, utils_js_1.callbackifyPromiseWithTimeout)(promise, onDone);\n  };\n}\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n  return new Promise((resolve, reject) => {\n    function handleIteration(iterResult) {\n      if (iterResult.done) {\n        resolve();\n        return;\n      }\n      const item = iterResult.value;\n      return new Promise(next => {\n        // Bit confusing, perhaps; we pass a `resolve` fn\n        // to the user, so they can decide when and if to continue.\n        // They can return false, or a promise which resolves to false, to break.\n        onItem(item, next);\n      }).then(shouldContinue => {\n        if (shouldContinue === false) {\n          return handleIteration({\n            done: true,\n            value: undefined\n          });\n        } else {\n          return asyncIteratorNext().then(handleIteration);\n        }\n      });\n    }\n    asyncIteratorNext().then(handleIteration).catch(reject);\n  });\n}\nfunction isReverseIteration(requestArgs) {\n  const args = [].slice.call(requestArgs);\n  const dataFromArgs = (0, utils_js_1.getDataFromArgs)(args);\n  return !!dataFromArgs.ending_before;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","makeAutoPaginationMethods","utils_js_1","require","V1Iterator","constructor","firstPagePromise","requestArgs","spec","stripeResource","index","pagePromise","promiseCache","currentPromise","iterate","pageResult","data","length","Error","reverseIteration","isReverseIteration","idx","done","has_more","getNextPage","nextPageResult","undefined","_pageResult","_next","next","nextPromise","ret","V1ListIterator","lastId","getLastId","_makeRequest","V1SearchIterator","next_page","page","V2ListIterator","currentPageIterator","Symbol","iterator","nextPageUrl","next_page_url","turnPage","fullPath","Promise","resolve","result","nextPageIterator","apiMode","getAPIMode","path","methodType","makeAutoPaginationMethodsFromIterator","autoPagingEach","makeAutoPagingEach","args","autoPagingToArray","makeAutoPagingToArray","autoPaginationMethods","return","getAsyncIteratorSymbol","asyncIterator","getDoneCallback","onDone","getItemCallback","onItem","_onItem","item","shouldContinue","listResult","lastIdx","lastItem","id","asyncIteratorNext","slice","call","arguments","autoPagePromise","wrapAsyncIteratorWithCallback","callbackifyPromiseWithTimeout","opts","limit","promise","reject","items","push","then","catch","handleIteration","iterResult","dataFromArgs","getDataFromArgs","ending_before"],"sources":["C:/Users/saibh/OneDrive/Documents/bharath/client/node_modules/stripe/cjs/autoPagination.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeAutoPaginationMethods = void 0;\nconst utils_js_1 = require(\"./utils.js\");\nclass V1Iterator {\n    constructor(firstPagePromise, requestArgs, spec, stripeResource) {\n        this.index = 0;\n        this.pagePromise = firstPagePromise;\n        this.promiseCache = { currentPromise: null };\n        this.requestArgs = requestArgs;\n        this.spec = spec;\n        this.stripeResource = stripeResource;\n    }\n    async iterate(pageResult) {\n        if (!(pageResult &&\n            pageResult.data &&\n            typeof pageResult.data.length === 'number')) {\n            throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n        }\n        const reverseIteration = isReverseIteration(this.requestArgs);\n        if (this.index < pageResult.data.length) {\n            const idx = reverseIteration\n                ? pageResult.data.length - 1 - this.index\n                : this.index;\n            const value = pageResult.data[idx];\n            this.index += 1;\n            return { value, done: false };\n        }\n        else if (pageResult.has_more) {\n            // Reset counter, request next page, and recurse.\n            this.index = 0;\n            this.pagePromise = this.getNextPage(pageResult);\n            const nextPageResult = await this.pagePromise;\n            return this.iterate(nextPageResult);\n        }\n        return { done: true, value: undefined };\n    }\n    /** @abstract */\n    getNextPage(_pageResult) {\n        throw new Error('Unimplemented');\n    }\n    async _next() {\n        return this.iterate(await this.pagePromise);\n    }\n    next() {\n        /**\n         * If a user calls `.next()` multiple times in parallel,\n         * return the same result until something has resolved\n         * to prevent page-turning race conditions.\n         */\n        if (this.promiseCache.currentPromise) {\n            return this.promiseCache.currentPromise;\n        }\n        const nextPromise = (async () => {\n            const ret = await this._next();\n            this.promiseCache.currentPromise = null;\n            return ret;\n        })();\n        this.promiseCache.currentPromise = nextPromise;\n        return nextPromise;\n    }\n}\nclass V1ListIterator extends V1Iterator {\n    getNextPage(pageResult) {\n        const reverseIteration = isReverseIteration(this.requestArgs);\n        const lastId = getLastId(pageResult, reverseIteration);\n        return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n            [reverseIteration ? 'ending_before' : 'starting_after']: lastId,\n        });\n    }\n}\nclass V1SearchIterator extends V1Iterator {\n    getNextPage(pageResult) {\n        if (!pageResult.next_page) {\n            throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');\n        }\n        return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n            page: pageResult.next_page,\n        });\n    }\n}\nclass V2ListIterator {\n    constructor(firstPagePromise, requestArgs, spec, stripeResource) {\n        this.currentPageIterator = (async () => {\n            const page = await firstPagePromise;\n            return page.data[Symbol.iterator]();\n        })();\n        this.nextPageUrl = (async () => {\n            const page = await firstPagePromise;\n            return page.next_page_url || null;\n        })();\n        this.requestArgs = requestArgs;\n        this.spec = spec;\n        this.stripeResource = stripeResource;\n    }\n    async turnPage() {\n        const nextPageUrl = await this.nextPageUrl;\n        if (!nextPageUrl)\n            return null;\n        this.spec.fullPath = nextPageUrl;\n        const page = await this.stripeResource._makeRequest([], this.spec, {});\n        this.nextPageUrl = Promise.resolve(page.next_page_url);\n        this.currentPageIterator = Promise.resolve(page.data[Symbol.iterator]());\n        return this.currentPageIterator;\n    }\n    async next() {\n        {\n            const result = (await this.currentPageIterator).next();\n            if (!result.done)\n                return { done: false, value: result.value };\n        }\n        const nextPageIterator = await this.turnPage();\n        if (!nextPageIterator) {\n            return { done: true, value: undefined };\n        }\n        const result = nextPageIterator.next();\n        if (!result.done)\n            return { done: false, value: result.value };\n        return { done: true, value: undefined };\n    }\n}\nconst makeAutoPaginationMethods = (stripeResource, requestArgs, spec, firstPagePromise) => {\n    const apiMode = (0, utils_js_1.getAPIMode)(spec.fullPath || spec.path);\n    if (apiMode !== 'v2' && spec.methodType === 'search') {\n        return makeAutoPaginationMethodsFromIterator(new V1SearchIterator(firstPagePromise, requestArgs, spec, stripeResource));\n    }\n    if (apiMode !== 'v2' && spec.methodType === 'list') {\n        return makeAutoPaginationMethodsFromIterator(new V1ListIterator(firstPagePromise, requestArgs, spec, stripeResource));\n    }\n    if (apiMode === 'v2' && spec.methodType === 'list') {\n        return makeAutoPaginationMethodsFromIterator(new V2ListIterator(firstPagePromise, requestArgs, spec, stripeResource));\n    }\n    return null;\n};\nexports.makeAutoPaginationMethods = makeAutoPaginationMethods;\nconst makeAutoPaginationMethodsFromIterator = (iterator) => {\n    const autoPagingEach = makeAutoPagingEach((...args) => iterator.next(...args));\n    const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n    const autoPaginationMethods = {\n        autoPagingEach,\n        autoPagingToArray,\n        // Async iterator functions:\n        next: () => iterator.next(),\n        return: () => {\n            // This is required for `break`.\n            return {};\n        },\n        [getAsyncIteratorSymbol()]: () => {\n            return autoPaginationMethods;\n        },\n    };\n    return autoPaginationMethods;\n};\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\nfunction getAsyncIteratorSymbol() {\n    if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n        return Symbol.asyncIterator;\n    }\n    // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n    return '@@asyncIterator';\n}\nfunction getDoneCallback(args) {\n    if (args.length < 2) {\n        return null;\n    }\n    const onDone = args[1];\n    if (typeof onDone !== 'function') {\n        throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);\n    }\n    return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\nfunction getItemCallback(args) {\n    if (args.length === 0) {\n        return undefined;\n    }\n    const onItem = args[0];\n    if (typeof onItem !== 'function') {\n        throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);\n    }\n    // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n    if (onItem.length === 2) {\n        return onItem;\n    }\n    if (onItem.length > 2) {\n        throw Error(`The \\`onItem\\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);\n    }\n    // This magically handles all three of these usecases (the latter two being functionally identical):\n    // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n    // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n    // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n    return function _onItem(item, next) {\n        const shouldContinue = onItem(item);\n        next(shouldContinue);\n    };\n}\nfunction getLastId(listResult, reverseIteration) {\n    const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n    const lastItem = listResult.data[lastIdx];\n    const lastId = lastItem && lastItem.id;\n    if (!lastId) {\n        throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n    }\n    return lastId;\n}\nfunction makeAutoPagingEach(asyncIteratorNext) {\n    return function autoPagingEach( /* onItem?, onDone? */) {\n        const args = [].slice.call(arguments);\n        const onItem = getItemCallback(args);\n        const onDone = getDoneCallback(args);\n        if (args.length > 2) {\n            throw Error(`autoPagingEach takes up to two arguments; received ${args}`);\n        }\n        const autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext, \n        // @ts-ignore we might need a null check\n        onItem);\n        return (0, utils_js_1.callbackifyPromiseWithTimeout)(autoPagePromise, onDone);\n    };\n}\nfunction makeAutoPagingToArray(autoPagingEach) {\n    return function autoPagingToArray(opts, onDone) {\n        const limit = opts && opts.limit;\n        if (!limit) {\n            throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');\n        }\n        if (limit > 10000) {\n            throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n        }\n        const promise = new Promise((resolve, reject) => {\n            const items = [];\n            autoPagingEach((item) => {\n                items.push(item);\n                if (items.length >= limit) {\n                    return false;\n                }\n            })\n                .then(() => {\n                resolve(items);\n            })\n                .catch(reject);\n        });\n        // @ts-ignore\n        return (0, utils_js_1.callbackifyPromiseWithTimeout)(promise, onDone);\n    };\n}\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n    return new Promise((resolve, reject) => {\n        function handleIteration(iterResult) {\n            if (iterResult.done) {\n                resolve();\n                return;\n            }\n            const item = iterResult.value;\n            return new Promise((next) => {\n                // Bit confusing, perhaps; we pass a `resolve` fn\n                // to the user, so they can decide when and if to continue.\n                // They can return false, or a promise which resolves to false, to break.\n                onItem(item, next);\n            }).then((shouldContinue) => {\n                if (shouldContinue === false) {\n                    return handleIteration({ done: true, value: undefined });\n                }\n                else {\n                    return asyncIteratorNext().then(handleIteration);\n                }\n            });\n        }\n        asyncIteratorNext()\n            .then(handleIteration)\n            .catch(reject);\n    });\n}\nfunction isReverseIteration(requestArgs) {\n    const args = [].slice.call(requestArgs);\n    const dataFromArgs = (0, utils_js_1.getDataFromArgs)(args);\n    return !!dataFromArgs.ending_before;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}